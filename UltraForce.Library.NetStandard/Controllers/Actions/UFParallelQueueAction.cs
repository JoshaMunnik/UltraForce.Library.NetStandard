// <copyright file="UFParallelQueueAction.cs" company="Ultra Force Development">
// Ultra Force Library - Copyright (C) 2018 Ultra Force Development
// </copyright>
// <author>Josha Munnik</author>
// <email>josha@ultraforce.com</email>
// <license>
// The MIT License (MIT)
// Copyright (C) 2018 Ultra Force Development
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to 
// deal in the Software without restriction, including without limitation the 
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
// IN THE SOFTWARE.
// </license>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using UltraForce.Library.NetStandard.Tools;
using UltraForce.Library.NetStandard.Errors;

namespace UltraForce.Library.NetStandard.Controllers.Actions
{
  /// <summary>
  /// <see cref="UFParallelQueueAction"/> implements an action queue that can run a number of actions at the same time.
  /// <para>
  /// It extends <see cref="UFQueueableAction"/> so the queue can be placed into other queues if needed.
  /// </para>
  /// </summary>
  public abstract class UFParallelQueueAction : UFQueueableAction, IUFPausableAction
  {
    #region private vars

    /// <summary>
    /// Original actions list
    /// </summary>
    private readonly IUFQueueableAction[] m_actions;

    /// <summary>
    /// List of running actions
    /// </summary>
    private readonly IUFQueueableAction?[] m_runningActions;

    /// <summary>
    /// The token source is used while running the actions. If it is null no actions are running.
    /// </summary>
    private CancellationTokenSource? m_tokenSource;

    /// <summary>
    /// Number of actions to run concurrently
    /// </summary>
    private readonly int m_concurrentCount;

    /// <summary>
    /// Total progress weight of all actions.
    /// </summary>
    private readonly double m_totalProgressWeight;

    /// <summary>
    /// Sum of progress weight of all actions that have finished.
    /// </summary>
    private double m_doneProgressWeight;

    /// <summary>
    /// This task is created when the queue gets paused and will be set to true if the queue is resumed.
    /// </summary>
    private TaskCompletionSource<bool>? m_pauseFinished;

    /// <summary>
    /// Points to the current action being processed
    /// </summary>
    private int m_actionIndex;

    /// <summary>
    /// Combines the error messages generated by the actions.
    /// </summary>
    private string? m_errorMessage;

    /// <summary>
    /// Contains RunAsync tasks from actions 
    /// </summary>
    private List<Task>? m_tasks;

    #endregion

    #region public methods

    /// <summary>
    /// Constructs an instance of <see cref="UFParallelQueueAction"/> that will run a certain number of actions at
    /// the same time.
    /// </summary>
    /// <param name="aConcurrentCount">
    /// Maximum number of actions that should run at the same time.
    /// </param>
    /// <param name="anActions">
    /// One or more actions to run
    /// </param>
    protected UFParallelQueueAction(int aConcurrentCount, params IUFQueueableAction[] anActions)
    {
      this.m_actions = anActions;
      this.m_runningActions = new IUFQueueableAction[this.m_actions.Length];
      this.m_concurrentCount = aConcurrentCount;
      this.m_doneProgressWeight = 0.0f;
      this.m_pauseFinished = null;
      this.m_totalProgressWeight = anActions.Sum(
        action => UFProgressTools.GetProgressWeight(action)
      );
    }

    /// <summary>
    /// Constructs an instance of <see cref="UFParallelQueueAction"/> that will run all the actions at the same time.
    /// </summary>
    /// <param name="anActions">
    /// One or more actions to run
    /// </param>
    protected UFParallelQueueAction(params IUFQueueableAction[] anActions)
      : this(anActions.Length, anActions)
    {
    }

    #endregion

    #region IUFQueueableAction

    /// <summary>
    /// Runs all stored actions at the same time.
    /// </summary>
    /// <remarks>
    /// If the queue is already running, the method just returns true.
    /// <para>
    /// Actions are processed from first to last. Actions should never assume a previous action has finished before
    /// they are started (unless only one action is allowed to run).
    /// </para>
    /// </remarks>
    /// <param name="aToken">Cancellation token</param>
    /// <returns>
    /// <c>True</c> if all actions returned true and there was no cancellation by aToken
    /// </returns>
    public override async Task<bool> RunAsync(CancellationToken aToken)
    {
      if (this.Running)
      {
        return true;
      }
      using (this.m_tokenSource = CancellationTokenSource.CreateLinkedTokenSource(aToken))
      {
        this.m_doneProgressWeight = 0.0f;
        this.m_tasks = new List<Task>(this.m_concurrentCount);
        this.m_actionIndex = 0;
        this.m_errorMessage = "";
        await this.RunActionsAsync();
        // success if no task did cancel or threw an exception
        bool result = !this.m_tokenSource.IsCancellationRequested;
        this.m_tokenSource = null;
        this.m_tasks = null;
        // throw an exception if one or more actions threw an exception
        if (this.m_errorMessage.Length > 0)
        {
          throw new UFQueueException(
            $"{this.GetType().Name}: one or more actions raised an exception: {this.m_errorMessage}"
          );
        }
        return result;
      }
    }

    #endregion

    #region IUFPausableAction

    /// <summary>
    /// Pauses all actions that are still running.
    /// </summary>
    public void Pause()
    {
      if (!this.Paused)
      {
        this.Paused = true;
        this.m_pauseFinished = new TaskCompletionSource<bool>();
        if (this.Running)
        {
          foreach (IUFQueueableAction? action in this.m_runningActions)
          {
            if (action is IUFPausableAction pausable)
            {
              pausable.Pause();
            }
          }
        }
      }
    }

    /// <summary>
    /// Resume all actions that are still running.
    /// </summary>
    public void Resume()
    {
      if (!this.Paused)
      {
        return;
      }
      this.Paused = false;
      this.m_pauseFinished!.SetResult(true);
      this.m_pauseFinished = null;
      if (!this.Running)
      {
        return;
      }
      foreach (IUFQueueableAction? action in this.m_runningActions)
      {
        if (action is IUFPausableAction pausable)
        {
          pausable.Resume();
        }
      }
    }

    #endregion

    #region public properties

    /// <summary>
    /// This property is <c>true</c> so long actions are being start from 
    /// the queue.
    /// </summary>
    public bool Running => this.m_tokenSource != null;

    /// <summary>
    /// Gets the number of action still running.
    /// </summary>
    public int RunningCount => this.m_runningActions.Count(
      action => action != null
    );

    /// <summary>
    /// Is true while queue is paused.
    /// </summary>
    public bool Paused { get; private set; }

    #endregion

    #region IUFProgress

    /// <summary>
    /// Gets the progress, include the progress of any running action.
    /// </summary>
    public override double Progress
    {
      get
      {
        double progressSum = this.m_runningActions
          .Where(action => action != null)
          .Sum(
            action =>
              UFProgressTools.GetProgressWeight(action!) * UFProgressTools.GetProgress(action!)
          );
        return (progressSum + this.m_doneProgressWeight) / this.m_totalProgressWeight;
      }
    }

    #endregion

    #region protected methods

    /// <summary>
    /// Gets all current running actions
    /// </summary>
    /// <returns>Running actions</returns>
    protected IEnumerable<IUFQueueableAction> GetRunningActions()
    {
      return this.m_runningActions.Where(action => action != null).Select(action => action!);
    }

    #endregion

    #region private methods

    /// <summary>
    /// Runs all the actions and returns once all actions have finished.
    /// </summary>
    private async Task RunActionsAsync()
    {
      // keep looping while not cancelled and there are still action to add or tasks to wait for
      while (
        !this.m_tokenSource!.IsCancellationRequested
        && ((this.m_actionIndex < this.m_actions.Length) || (this.m_tasks!.Count > 0))
      )
      {
        await this.CheckAndWaitForPauseAsync();
        this.AddTasks();
        await this.WaitForTaskToFinishAsync();
      }
    }

    /// <summary>
    /// Checks if pause is active and wait for it
    /// </summary>
    private async Task CheckAndWaitForPauseAsync()
    {
      if (this.m_pauseFinished != null)
      {
        await this.m_pauseFinished.Task;
      }
    }

    /// <summary>
    /// Waits for one of the running tasks to finish and updates the error message if necessary.
    /// </summary>
    private async Task WaitForTaskToFinishAsync()
    {
      Task done = await Task.WhenAny(this.m_tasks);
      this.m_tasks!.Remove(done);
    }

    /// <summary>
    /// Adds tasks until the concurrent count is reached or there are no more tasks to add.
    /// </summary>
    private void AddTasks()
    {
      while (
        !this.m_tokenSource!.IsCancellationRequested
        && (this.m_actionIndex < this.m_actions.Length)
        && (this.m_tasks!.Count < this.m_concurrentCount)
      )
      {
        this.m_tasks.Add(this.RunAction(this.m_actionIndex));
        this.m_actionIndex++;
      }
    }

    /// <summary>
    /// Runs an action. Once finished, clear the reference in the running list. If the action returned false or threw
    /// an exception, call cancel on the token source to cancel all other actions and prevent new actions from being
    /// run.
    /// </summary>
    /// <param name="anIndex">Index to running action</param>
    /// <returns>
    /// <c>null</c> or an error message if the action threw an exception.
    /// </returns>
    private async Task RunAction(int anIndex)
    {
      // get action and store it in the running list while it is active
      IUFQueueableAction action = this.m_actions[anIndex];
      this.m_runningActions[anIndex] = action;
      bool actionResult;
      try
      {
        actionResult = await action.RunAsync(this.m_tokenSource!.Token);
      }
      catch (Exception error)
      {
        // an error will also stop all other actions
        actionResult = false;
        lock (this.m_errorMessage!)
        {
          this.m_errorMessage = UFStringTools.Add(
            this.m_errorMessage,
            $"{action.GetType().Name}: {error.Message}{UFExceptionTools.GetInnerExceptionMessages(error)}"
          );
        }
      }
      // either cancel all other actions or increase progress weight
      if (!actionResult)
      {
        this.m_tokenSource!.Cancel();
      }
      else
      {
        this.m_doneProgressWeight += UFProgressTools.GetProgressWeight(action);
      }
      // action no longer running
      this.m_runningActions[anIndex] = null;
    }

    #endregion
  }
}